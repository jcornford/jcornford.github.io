---
layout: post
title: First post...
subtitle: Plotting lines of best-fit using python
---

Coding and maths really help each other, put this in the home page, assume relatively  decent at coding.

#### Warning: This post assumes you didn't do much maths at university/college, (specifically least squares fitting) and serves as a starter for future, more complex posts!

Fitting a line of best-fit **is an example of Machine Learning**. It is also considered by many to be a basic thing 
that you can just "do" when plotting data - a problem I lay firmly at Excel's feet. It's not basic or simple, and shouldn't be
considered so. However, as a first year graduate student, newly obssesed with python and late to make figures for a lab presentation,
 this didn't matter to me. I just wanted to have graphs with nice lines...
 
So this first post is for the me of four years ago, with two aims:

1. Just give some simple code to make some lines
2. Spark an interest and understanding of why **aim 1.** isn't a good idea

## Give me a straight line already:

The easiest way to get yourself a line is with numpy's polyfit function:

```python
import numpy as np
import matplotlib.pyplot as plt

def give_me_a_straight_line(x,y):
    w, b  = np.polyfit(x,y,deg=1) # not going to be correct code
    print (w,b)
    line  = w*x + b
    return line

y = np.array([0,3,5,8,6,4,3,6,7,8])
x = np.arange(10)

l = give_me_a_straight_line(x,y)

plt.plot(x,y, 'o')
plt.plot(x,l, 'r--')
```

There: if all you wanted was the code for a straight line through your data, you should be all set. However, we really should talk about what you are actually doing with this code (as no doubt a small part of you wants to know?). You are fitting a function of the following form:

$$ \mathbf{y} = w\mathbf{x} + b $$

Where:<br>
$\mathbf{x}$ is your vector of x values (think list or 1D-array)<br>
$\mathbf{y}$ is your vector of y values<br>
$w$ is a scalar that weights the $x$ value <br>
$b$ is a scalar offset or bias (intercept)

In essence, the two parameters you are fitting, $w$ & $b$, take the $x$ value, and predict what the corresponding $y$ value should be. How does np.polyfit do this?! Well, the fitting procedure that np.polyfit uses is a least squares fit, to which the solution, happily, has a neat closed form expression:

$$ (\mathbf{X}^T\mathbf{X})^{-1}\mathbf{X}^{T}\mathbf{y} = \mathbf{\beta} $$

Wait, what's just happened? Don't worry, we'll go through how we get to this "neat expression" in the **next post**, but more pressingly, why has $\mathbf{x}$ changed to $\mathbf{X}$ and what is $\mathbf{\beta}$?

$\mathbf{\beta}$ first: this is now a vector (think list), and it looks like $[w, b]^T$ (it's a column vector, hence the $^T$). Therefore $\mathbf{\beta}$[0] will give you your x-weight, $w$, and $\mathbf{\beta}$[1] your bias, $b$. Second, $\mathbf{X}$ is a matrix (think array), with two columns: the orginal $\mathbf{x}$ vector, which has now also been augmented by an equally long column of ones, in order to fit the $b$ parameter.

## Lets plug this in to our function already!


```python
def give_me_a_straight_line_without_polyfit(x,y):
    
    # first augment the x vector with ones
    ones_vec = np.ones(x.shape)
    X = np.vstack([x, ones_vec]).T #.T as we want two columns
    
    # now plugin our least sqaures "solution"
    XX   = np.linalg.inv(np.dot(X.T, X))
    Xt_y = np.dot(X.T, y.T)
    beta = np.dot(XX, Xt_y)
    
    line = beta[0]*x + beta[1]
    return line

y = np.array([0,3,5,8,6,4,3,6,7,8])
x = np.arange(10)

l = give_me_a_straight_line_without_polyfit(x,y)
plt.plot(x,y, 'o')
plt.plot(x,l, 'r--')

```

## Give me a line that goes nicely through my points:
**Sigh**. I'm firmly a member of the camp of "your-line-reflects-your-hypothesis-on-the-data-generating-process". Ie.
 **don't** just line to go through all your datapoints, (like the default **abomination in excel**) unless you think the underlying relationship 
 between x and y is truely of that nature. If in doubt use a straight line, or let the datapoints speak for themselves.
 
 However, if you insist:
 
```python

def give_me_a_nice_line(x,y):
    y = np.polyfit(x, deg=1) # not going to be correct code
    return y
    
```

What's going on here?

